# OS

- メモリ管理
- ファイル管理
- HW管理

## ソフトウェア分類

```mermaid
graph LR;
  応用ソフト --- |DBなど|ミドルウェア
  応用ソフト --- 基本ソフトウェア
subgraph System Software
  ミドルウェア --- 基本ソフトウェア
end
  基本ソフトウェア --- HW
```

```mermaid
graph LR;
subgraph OS
  基本ソフトウェア-->制御プログラム
  基本ソフトウェア-->言語処理プログラム
  基本ソフトウェア-->サービスプログラム
    subgraph Kernel
      制御プログラム---Proccess
      制御プログラム---TaskManagement
      制御プログラム---MemoryManagement
    end
  
    言語処理プログラム---|翻訳|Java
    言語処理プログラム---|翻訳|C
    言語処理プログラム---|翻訳|etc..
  
  
    サービスプログラム
  
end
style OS fill:#8aa,stroke:#333,stroke-width:3px,color:fff
```

## API

>アプリケーション側からOSの機能を呼び出すためのインターフェース

- 開発効率アップ
- 操作性の統一
- 互換性の確保

## タスク管理

### Jobは実行単位であるtaskに分解される

```mermaid
graph LR
Job --> Task1
Job --> Task2
Job --> Task3
```

### Taskの状態遷移

```mermaid
graph LR
RUN --> |入出力中|WAIT
READY --> |優先権GET|RUN
WAIT --> |実行可能|READY
RUN --> |優先順位変更|READY
RUN --> |タスク消失|TERMINATE
```

タスクがたまっていき、使用権を得るまで待つ。
使用権を管理するのはディスパッチャの役割。

### ディスパッチャ

- 到着順
- 優先順
- ラウンドロビン...一定時間単位で使用権の付与、終わらないタスクは最後に回される

## マルチプログラミング

> CPUの遊休時間を減らすために処理を並行して行う

```mermaid
gantt
dateFormat  ss
title Multi Programming
section A section

Active CPU               :active,  des2, 1, 3s
Future task1               :         des3, after des2, 5s
Future task2               :         des4, after des3, 5s
Active CPU               :des2, a, 3s
```

## 実記憶管理

限られた主記憶空間を効率良く使うための管理方法

### 固定区画

>固定長のパーティションに区切り、プログラムを割り当てる

### 可変区画

>プログラムをロードする過程で必要なサイズに区切る

### フラグメンテーション＆メモリコンパクション

可変で良いように見えるがプログラムの終了が上から順とは限らない=> 断片化する

**これを解決するのがメモリコンパクション（ガベージコレクション）**
断片化した領域にプログラムを並べ直す。

### オーバーレイ方式

> そもそも実行したいプログラムが容量より大きいとロードできないので、プログラムをセグメント化し必要な文だけをメモリにロードする方法

### スワッピング方式

> 割り込み処理などの際、優先度の低いプログラムを補助記憶装置へ一旦退避させる

## 再配置可能なプログラム

メモリのアドレスが変わるけど大丈夫なのか問題。
=> **ベースアドレス方式**でロードされたときの先頭アドレスからの差分でアドレス位置を指定できる。

そのため、どこにロードされても大丈夫。このような性質のプログラムを再配置可能プログラムという。

- 再配置可能　どこにロードされても大丈夫
- 再使用可能　再ロードせず繰り返し実行できる
- 再入可能　データ部分をタスクごとに持つことで複数タスクから呼び出しても干渉しない

```mermaid
graph LR


  programA --> 手続き部分
  programB --> 手続き部分
subgraph programC
  手続き部分 --> データ部分A
  手続き部分 --> データ部分B
end

```

- 再帰的　実行中に自分自身を呼び出せる(仮にProgramAとすると) 

```mermaid
graph TD
subgraph folder group
  folderA---folderB---folderC
end
programA-->|look up by programA|folderA
programA-->|keep statement|stackArea
programA-->|call programA:loop|programA
programA-->|look up by programA|folderB
programA-->|look up by programA|folderC

```

## 仮想記憶管理

主記憶と補助記憶を組み合わせて、大量の記憶装置があるように見せる。
物理的な記憶装置は実記憶という。

実際のデータは実記憶に保存されるが、物理的存在を隠蔽することで保管されるプログラム自体は何も考えなくて済む！->フラグメンテーションなどの問題をプログラムが考えなくていい

### 動的アドレス変換

仮想アドレス->実アドレスへの変換

- MMU(Memory Management Unit)が担当
- MMUはCPUに内蔵

### なぜ実記憶よりも大きなサイズを扱えるか

-> 実記憶だけでなく、補助記憶にも拡大して保存するため

```mermaid
graph LR
programm-->
|実記憶隠蔽|仮想記憶-->
MMU

MMU-->|動的アドレス変換|実記憶
MMU-->|動的アドレス変換|補助記憶

```

### 仮想記憶の方式 

- ページング方式　仮想アドレス空間を固定長に区切る
- セグメント方式　仮想アドレス空間を可変長に区切る

仮想記憶と実記憶の紐付けはページテーブルで管理される

#### ページテーブルimage

| ページ   | 存在 | 物理ページアドレス |
|-------|----|-----------|
| ページ0  | 0  |           |
| ページ1  | 0  |           |
| ページ2  | 0  |           |
| ページ3  | 0  |           |
| ページ4  | 1  | ページ5      |
| ページ5  | 1  | ページ7      |
| ページ6  | 1  | ページ3      |
| ページ7  | 1  | ページ9      |
| ページ8  | 0  |           |
| ページ9  | 1  | ページ10     |
| ページ10 | 1  |           |
| ページ11 | 0  |           |
| ページ12 | 0  |           |
| ページ13 | 0  |           |
| ページ14 | 0  |           |
| ページ15 | 0  |

```mermaid
graph LR

subgraph 仮想記憶
仮想記憶1
仮想記憶2
仮想記憶3
仮想記憶4
仮想記憶5
end

subgraph ページテーブル
ページ2
ページ3
ページ4
ページ5
ページ6
ページ7
end

仮想記憶3---|A|ページ4
仮想記憶4---|B|ページ5
仮想記憶5---|C|ページ6

ページ4-.-|A|実記憶1
ページ5-.-|B|実記憶2
ページ6-.-|C|実記憶4

補助記憶-->|A|実記憶1
補助記憶-->|B|実記憶2
補助記憶-->|C|実記憶4

subgraph 実記憶
実記憶1
実記憶2
実記憶3
実記憶4
実記憶5
end

subgraph 補助
補助記憶
end
```

一旦仮想記憶に読み込んだら、補助記憶装置に読み込ませておき、
必要になった時点で実記憶に読み込む->デマンドページング

